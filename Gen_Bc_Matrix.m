function LHS = Gen_Bc_Matrix(Edges, Loops, LHS, abscissa, weight)
% GEN_BC_MATRIX iterates through the edges and calls the functions that 
% generate the BC block of the boundary matrix in the LHS. 
%
% GEN_BC_MATRIX is called by MAIN***. It receives as input data the Edges
% and Loops structures, the LHS matrix (that is, the matrix of coefficients
% of the solving system), and the Gauss-Legendre integration parameters
% abscissa and weights. It returns to MAIN*** the LHS matrix with the BC
% blocks of all elements inserted at the correct positions (as determined
% in ASSIGNPARTSCOMPL).
%
%
% BIBLIOGRAPHY
% 1. FreeHyTE Page - https://sites.google.com/site/ionutdmoldovan/freehyte
% 2. Moldovan ID, Cismasiu I - FreeHyTE: theoretical bases and developer’s 
% manual, https://drive.google.com/file/d/0BxuR3pKS2hNHTzB2N2Q4cXZKcGc/view
% 3. FreeHyTE Heat HTTE User's Manual - 
%    https://drive.google.com/drive/folders/0BxuR3pKS2hNHaFhiSjZHOE9TMzg
% 4. Moldovan ID, Coutinho AP, Cismasiu I - Hybrid-Trefftz finite elements
% for non-homogeneous parabolic problems using a novel dual reciprocity
% variant, Engineering Analysis with Boundary Elements, under review, 2018.
%
% GEN_BC_MATRIX computes the internal product between the following bases, 
% expressed in a polar (r,th) referential:
% * the temperature basis U generated by Bessel function of first kind, of
% order n and argument z= ohm*r (ohm is the generalized frequency)
%      U = Jn(z).* exp(1i*Th.*n);
% * the boundary flux basis Z (on the Dirichlet and Robin boundaries), 
% defined by Chebyshev polynomials,
%      Z  = cos(m*ArcCos(abscissa))
% where n and m are the line and column of the current term in matrix Bc.
%
% Further details on the structure of the solving system are presented in 
% reference [2] (Section 6.2).
%

%% Start iteration on edges
for ii=1:length(Edges.type)
    
    % Boundary blocks are constructed for Dirichlet (and interior) and
    % Robin boundaries. 
    if (strcmpi(Edges.type(ii),'D') || strcmpi(Edges.type(ii),'R'))
       % LocEdge is a local structure where the features of the current
       % edge which are directly useful for the calculation of the
       % boundary block are stored.
       LocEdge =struct('nini',Edges.nini(ii),'nfin',Edges.nfin(ii),...
            'parametric',Edges.parametric(ii,:), 'lleft',Edges.lleft(ii),...
            'lright',Edges.lright(ii), 'order',Edges.order(ii),...
            'insert',Edges.insert(ii), 'dim',Edges.dim(ii));
 
       % Generating the boundary block corresponding to the current edge
       % and its LEFT finite element
       if LocEdge.lleft
            id = LocEdge.lleft;
            sign = 1.;
            % LocLoop is a local structure where the features of the left
            % element which are directly useful for the calculation of the
            % boundary block are stored.
            LocLoop = struct('id',id,'edges',Loops.edges(id,:),...
                'center',Loops.center(id,:),'order',Loops.orderC(id),...
                'ohm',Loops.ohm(id),...
                'insert',Loops.insertC(id),'dim',Loops.dimC(id));
            
            % Launching the function that computes the boundary
            % block Bc for the current edge ii and its left element
             Bci = sign*Bc_Matrix_i(LocEdge, LocLoop, abscissa, weight);
            
            % Inserting the matrix in the global LHS matrix
            LHS(LocLoop.insert:LocLoop.insert+LocLoop.dim-1,...
                LocEdge.insert:LocEdge.insert+LocEdge.dim-1) = -Bci;
            % Inserting the conjugate transposed in the global LHS matrix
            LHS(LocEdge.insert:LocEdge.insert+LocEdge.dim-1,...
                LocLoop.insert:LocLoop.insert+LocLoop.dim-1) = -Bci';            
            
        else                       % there should always be a left element
            error('local:consistencyChk',...
                'No left loop for edge %d. \n', ii);
        end
        
        % Generating the boundary block corresponding to the current edge
        % and its RIGHT finite element. 
        % NOTE: right elements exist for internal boundries only
        if LocEdge.lright
            id = LocEdge.lright;
            sign = -1.;
            % LocLoop is a local structure where the features of the right
            % element which are directly useful for the calculation of the
            % boundary block are stored.
            LocLoop = struct('id',id,'edges',Loops.edges(id,:),... 
                'center',Loops.center(id,:),'order',Loops.orderC(id,1),...
                'ohm',Loops.ohm(id),...
                'insert',Loops.insertC(id,1),'dim',Loops.dimC(id,1));
            
            % Computing the Bc matrix of edge ii, left loop
            Bci = sign*Bc_Matrix_i(LocEdge, LocLoop, abscissa, weight);
            
            % Inserting the matrix in the global LHS matrix
            LHS(LocLoop.insert:LocLoop.insert+LocLoop.dim-1,...
                LocEdge.insert:LocEdge.insert+LocEdge.dim-1) = -Bci;
            % Inserting the conjugate transposed in the global LHS matrix
            LHS(LocEdge.insert:LocEdge.insert+LocEdge.dim-1,...
                LocLoop.insert:LocLoop.insert+LocLoop.dim-1) = -Bci';            
        end
        
    end
    
end

end

function Bci = Bc_Matrix_i(LocEdge, LocLoop, abscissa, weight)

% BC_MATRIX_I is a local function that computes Bc boundary block for the 
% LocEdge edge and LocLoop element. The side is mapped to a [-1,1] interval 
% to perform the integration.

%% Initialization
n = -LocLoop.order:LocLoop.order;         % varies between -Nd and Nd
m = 0:LocEdge.order;                      % varies between 0 and M


%% Generating the geometric data
% The following code transforms the abscissa coordinates, expressed in
% the [-1,1] referential, to the polar coordinates required to compute
% the values of the basis functions. 

% Computing the length of the current edge
L = sqrt(LocEdge.parametric(3)^2 + LocEdge.parametric(4)^2); 

% Transforming the edge abscissa into local coordinates. The local
% referential is centered in the barycenter of the element, its axes
% aligned with the Cartesian axes of the global referential.
loc_x = LocEdge.parametric(1) - LocLoop.center(1) + 0.5 *...
    (abscissa + 1) * LocEdge.parametric(3); 
loc_y = LocEdge.parametric(2) - LocLoop.center(2) + 0.5 *...
    (abscissa + 1) * LocEdge.parametric(4);

% Transforming the local Cartesian coordinates into polar.
r = sqrt(loc_x.^2 + loc_y.^2); 
th = atan2(loc_y, loc_x);

%% Computing the basis functions for all integration points.

% Getting the Bessel functions' argument
z = LocLoop.ohm * r;

% Temperature basis
Ustar = conj(bsxfun(@besselj,n,z) .* exp(1i*th*n));

% Flux basis Z -> Chebyshev functions of degree 'm'
Z = cos(bsxfun(@times,m,acos(abscissa)));

Ustar = Ustar.'; % non-conjugate transpose
Z = Z.';

% creating the 3D variants of the matrices
Ustar3D(:,1,:) = Ustar; 
Z3D(1,:,:) = Z;

% this creates the 3D Bci matrix, one Gauss point per page
Bci3D = bsxfun(@times, Ustar3D, Z3D); 

% Performing the side integration 
w3D(1,1,:) = weight;
Bci = L/2 * sum(bsxfun(@times,Bci3D,w3D),3); 


end

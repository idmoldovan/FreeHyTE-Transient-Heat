function RHS = Gen_qg_Vector(Edges,Loops,BConds,RHS,abscissa,weight,time)
% GEN_QG_VECTOR iterates through the elements and calls the functions 
% that generate qgamma block of the free vector (RHS) of the solving
% system. qgamma is abbreviated as qg in the code.
%
% GEN_QG_VECTOR is called by MAIN***. 
% Input data:
% * Edges, Loops, and BCOnds structures, the RHS vector 
% (that is, the free vector of the solving system), the Gauss-Legendre 
% integration parameters abscissa and weight and the current time. 
% Output/Returns to MAIN*** :
% * the RHS vector with the qg blocks of all elements inserted at the 
% correct positions (as determined in ASSIGNPARTSCOMPL).
%
% BIBLIOGRAPHY
% 1. FreeHyTE Page - https://sites.google.com/site/ionutdmoldovan/freehyte
% 2. Moldovan ID, Cismasiu I - FreeHyTE: theoretical bases and developer’s 
% manual, https://drive.google.com/file/d/0BxuR3pKS2hNHTzB2N2Q4cXZKcGc/view
% 3. FreeHyTE Heat HTTE User's Manual - 
%    https://drive.google.com/drive/folders/0BxuR3pKS2hNHaFhiSjZHOE9TMzg
% 4. Moldovan ID, Coutinho AP, Cismasiu I - Hybrid-Trefftz finite elements
% for non-homogeneous parabolic problems using a novel dual reciprocity
% variant, Engineering Analysis with Boundary Elements, under review, 2018.
% 
% GEN_QG_VECTOR computes the internal product between the temperature basis
% U expressed in a polar (r,th) referential, generated by Bessel function 
% of the first kind, of order n and argument z,
%      U = Jn(z.).* exp(1i*Th.*n);
% and the applied normal flux field on the Neumann boundaries.
%

% * the boundary normal fluxe temperature function is defined as, 
% qg(x,t) = q(x) * qt(time)
% q(x) is a polynomial function, defined through its values in an
% arbitrary number of equally spaced points on the boundary. A polynomial
% interpolation is performed between these values to obtain the analytic
% expression of the applied fluxes. The degree of the polynomial is equal
% to the number of flux values, minus one. qt(time) is an
% arbitrary function of time, defined by any valid Matlab command in the
% GUI or as an input file (see Section 4.6 of reference [3]).
%
% Further details on the structure of the solving system are presented in
% reference [4] (Section 4.4).

% ************************************************************************
%% Sweeping the elements

for ii=1:length(Loops.area)
   % LocLoop is a structure where the features of the current
   % element which are directly useful for the calculation of the
   % qg block are stored.            
    LocLoop = struct('id',ii,'edges',Loops.edges(ii,:), 'center',...
        Loops.center(ii,:),'order',Loops.orderC(ii,1),...
        'ohm', Loops.ohm(ii),...
        'insert',Loops.insertC(ii,1),'dim',Loops.dimC(ii,1));
    
    % Computing the qg vector of element ii. Function Qg_Vector_i
    % is a local function defined below. 
    qgi = Qg_Vector_i(LocLoop, Edges, BConds, abscissa, weight,time);
    
    % Inserting the vector in the global RHS vector
    RHS(LocLoop.insert:LocLoop.insert+LocLoop.dim-1) = qgi;
    
end

end

function qgi = Qg_Vector_i(LocLoop,Edges,BConds,abscissa,weight,time)
%  QG_VECTOR_I local function computes the qg vector of the element LocLoop
% The sides are mapped to a [-1,1] interval to perform the integration

%% Initialization 
qgi = zeros(LocLoop.dim,1);
n = -LocLoop.order:LocLoop.order;

% Iterating on the edges for contour integration
for jj = 1:length(LocLoop.edges)
    
    id = LocLoop.edges(jj);  % number of the jj-th edge of the loop
    
    % qg vector is only calculated on the Neumann boundaries
    if strcmpi(Edges.type(id),'N')    
       % LocEdge is a local structure where the features of the current
       % edge which are directly useful for the calculation of the
       % qg block are stored.     
       LocEdge =  struct('id',id,'nini',Edges.nini(id), 'nfin',Edges.nfin(id),...
            'parametric',Edges.parametric(id,:),'lleft',Edges.lleft(id),...
            'lright',Edges.lright(id));
        
        if LocEdge.lright  % exterior Neumann sides cannot have right loops
            error('local:consistencyChk',...
                'Exterior edge %d cannot have a right element. \n',...
                LocEdge.id);
        end
        
        %% Generating the geometric data
        % The following code transforms the abscissa coordinates, expressed in
        % the [-1,1] referential, to the polar coordinates required to compute
        % the values of the basis functions. 
        
        % Computing the length of the current edge
        L = sqrt(LocEdge.parametric(3)^2 + LocEdge.parametric(4)^2);
        
        % Transforming the edge abscissa into local coordinates. The local
        % referential is centered in the barycenter of the element, its axes
        % aligned with the Cartesian axes of the global referential.
        loc_x = LocEdge.parametric(1) - LocLoop.center(1) + 0.5 *...
            (abscissa + 1) * LocEdge.parametric(3); 
        loc_y = LocEdge.parametric(2) - LocLoop.center(2) + 0.5 *...
            (abscissa + 1) * LocEdge.parametric(4);
        
        % Transforming the local Cartesian coordinates into polar.
        r = sqrt(loc_x.^2 + loc_y.^2);  
        th = atan2(loc_y, loc_x);
        
        %% Computing the basis functions for all integration points
        % Computing the arguments of the basis functions
        z = LocLoop.ohm * r;
        
        % Temperature basis in polar coordinates
        Ustar = conj(bsxfun(@besselj,n,z) .* exp(1i*th*n));
        
        Ustar = Ustar.'; % non-conjugate transpose
        
        % Computing the values of the flux at the abscissas:
        % obtaining the equally spaced points on [-1,1] interval where the
        % fluxes are defined and stored in BConds.Neumann
        a = linspace(-1,1,length(BConds.Neumann{id}));
        
        % Obtaining the polynomial that gets the values in BConds.Neumann
        % at the points a
        pol = polyfit(a,BConds.Neumann{id},length(BConds.Neumann{id})-1);
        
        % computing the values of "pol" at the abscissas
        q = polyval(pol,abscissa);
        
        % assessing if the time variation of the heat flux was defined in
        % an input file or as an analytic expression
        if isnumeric(BConds.NeuTime{id})   % from an input file
            qt = BConds.NeuTime{id};
            % interpolates the input for the current time
            qinterp = interpn(qt(:,1),qt(:,2),time); 
            q = qinterp*q.';
        else   % analytic definition
            q = eval(BConds.NeuTime{id}{1})*q.'; 
        end
        
       % this creates the 2D qgi2D matrix,
       % one Gauss point per column
       qgi2D = bsxfun(@times, Ustar, q);
        
        % Computes the integral
        qgi = qgi + L/2 * sum(bsxfun(@times,qgi2D,weight.'),2); 
        
    end
    
end

end

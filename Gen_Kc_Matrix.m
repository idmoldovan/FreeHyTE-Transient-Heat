function LHS = Gen_Kc_Matrix(Edges, Loops, LHS, abscissa, weight)
% GEN_KC_MATRIX sweeps through the elements and calls the functions 
% that generate the KC block matrix in the LHS
%
% GEN_KC_MATRIX is called by MAIN***. 
% Input data: 
% the Edges and Loops structures, the LHS matrix (that is, the matrix of 
% coefficients of the solving system), and the Gauss-Legendre integration 
% parameters abscissa and weights. 
% Output/returns to MAIN***:
% the LHS matrix with the KC blocks  of all elements 
% inserted at the  correct positions (as determined in ASSIGNPARTSCOMPL).
%
% BIBLIOGRAPHY
% 1. FreeHyTE Page - https://sites.google.com/site/ionutdmoldovan/freehyte
% 2. Moldovan ID, Cismasiu I - FreeHyTE: theoretical bases and developer’s 
% manual, https://drive.google.com/file/d/0BxuR3pKS2hNHTzB2N2Q4cXZKcGc/view
% 3. FreeHyTE Heat HTTE User's Manual - 
%    https://drive.google.com/drive/folders/0BxuR3pKS2hNHaFhiSjZHOE9TMzg
% 4. Moldovan ID, Coutinho AP, Cismasiu I - Hybrid-Trefftz finite elements
% for non-homogeneous parabolic problems using a novel dual reciprocity
% variant, Engineering Analysis with Boundary Elements, under review, 2018.
%
%
% GEN_KC_MATRIX computes the internal product between the following bases
% expressed in a polar (r,th) referential:
% * the temperature basis U generated by Bessel function of first kind, of
% order n and argument z= ohm*r (ohm is the generalized frequency)
%      U = Jn(z).* exp(1i*Th.*n);
% * the boundary normal flux basis N * S, where S is the flux basis is, 
%         S = | Sr | = -k/2 *ohm * exp(i*Th.*m) | Jm-1(z) + Jm+1(z)|
%             | St |                           | i*Jm-1(z) + Jm+1(z) |
% and N is the directory cosine vector,
%         N = | nr  nt |
% In the above expressions, n and m are the line and column of the current 
% term in matrix Kc, k is the themal conductivity coefficient (see 
% INPUTPROC***), ohm is the generalized frequency (see TIMEGEN***)
% and nr and nt are the radial and tangential components of
% the outward unit normal to the current boundary.
%
% As typical of the Trefftz method, the temperature and flux bases solve
% exactly the governing (Helmholtz) equation in the domain of each element. 
% As a direct consequence, the stiffness matrix can be calculated using 
% boundary integrals only.
%
% The derivation of the bases from the solution of the Helmholtz
% equation is presented in reference [4] (Section 4.2).

%% Sweeping the elements
for ii=1:length(Loops.area)
    % LocLoop is a structure where the features of the current
    % element which are directly useful for the calculation of the
    % KC block are stored.
    LocLoop = struct('id',ii,'edges',Loops.edges(ii,:), 'center',...
        Loops.center(ii,:),'order',Loops.orderC(ii),'ohm',...
        Loops.ohm(ii),'insert',Loops.insertC(ii),'dim',Loops.dimC(ii),...
        'material',Loops.material(ii,:));
    
    % Computing the Kci matrix of element ii. Function KC_MATRIX_I is a
    % local function (see below).
    Kci = Kc_Matrix_i(LocLoop, Edges, abscissa, weight);
    
    % Inserting the matrix in the global LHS matrix. The insertion is made
    % at line & column Loops.insert(ii).
     LHS(LocLoop.insert(1):LocLoop.insert(1)+LocLoop.dim(1)-1,...
        LocLoop.insert(1):LocLoop.insert(1)+LocLoop.dim(1)-1) = Kci;
    
end

end

function Kci = Kc_Matrix_i(LocLoop, Edges, abscissa, weight)

% K_MATRIX_I is a local function that computes the  Kc matrix
% block of the LocLoop element. 
% The sides are mapped to a [-1,1] interval to perform the integrations.

%% Initialization 
% Initialization of the Kci block
Kci = zeros(LocLoop.dim(1,1));
k = LocLoop.material(1);

n = -LocLoop.order(1):LocLoop.order(1);
m = -LocLoop.order(1):LocLoop.order(1);

% Iterating on the edges for contour integration
for jj = 1:length(LocLoop.edges)  % contour integration
    
    id = LocLoop.edges(jj);  % number of the jj-th edge of the loop

    % LocEdge is a local structure where the features of the current
    % edge which are directly useful for the calculation of the
    % Kc blocks are stored.    
    LocEdge =  struct('id',id,'nini',Edges.nini(id), 'nfin',Edges.nfin(id),...
        'parametric',Edges.parametric(id,:),'lleft',Edges.lleft(id),...
        'lright',Edges.lright(id));
    
    %% Generating the geometric data
    % The following code transforms the abscissa coordinates, expressed in
    % the [-1,1] referential, to the polar coordinates required to compute
    % the values of the basis functions. The components of the outward
    % normal to the boundary in the radial and tangential directions are
    % also calculated. 
   
    % Computing the length of the current edge
    L = sqrt(LocEdge.parametric(3)^2 + LocEdge.parametric(4)^2); 
    
    % Transforming the edge abscissa into local coordinates. The local
    % referential is centered in the barycenter of the element, its axes
    % aligned with the Cartesian axes of the global referential. 
    loc_x = LocEdge.parametric(1) - LocLoop.center(1) + 0.5 *...
        (abscissa + 1) * LocEdge.parametric(3);  % x & y in local ccord
    loc_y = LocEdge.parametric(2) - LocLoop.center(2) + 0.5 *...
        (abscissa + 1) * LocEdge.parametric(4); 
    
    % Transforming the local Cartesian coordinates into polar.
    r = sqrt(loc_x.^2 + loc_y.^2);  
    th = atan2(loc_y, loc_x);
    
    % Computing the components of the outward normal in the Cartesian
    % directions.
    nx = LocEdge.parametric(4) / L;   
    ny = -1* LocEdge.parametric(3) / L;
    if LocEdge.lright==LocLoop.id  % if the element is on the right,
        nx = -nx;                  % change the sign of the normal
        ny = -ny;
    end
    
    % Computing the components of the outward normal in the polar
    % directions.
    nr = nx * cos(th) + ny * sin(th);   % normal in local r-th
    nth = -1*nx * sin(th) + ny * cos(th);
 
    %% Computing the basis functions for all integration points
    % Temperature basis in polar coordinates. U* -> the order is 'n'
    z = LocLoop.ohm * r;
    Ustar = conj(bsxfun(@besselj,n,z) .* exp(1i*th*n));
    
     % Polar components of the flux basis S. S -> the order is 'm'
    Sr = -0.5 *k * LocLoop.ohm * (bsxfun(@besselj,m-1,z) - bsxfun(@besselj,m+1,z)) ...
        .* exp(1i*th*m);
    Sth = -0.5 *k * LocLoop.ohm * 1i * (bsxfun(@besselj,m-1,z) + bsxfun(@besselj,m+1,z)) ...
        .* exp(1i*th*m);
   
    %% Computing the integral on the side
    % The integral is the internal product between the temperature basis U*
    % and the normal flux basis N*S
   
    NS = diag(nr)*Sr + diag(nth)*Sth;
    
    Ustar = Ustar.'; % non-conjugate transpose
    NS = NS.';
    
    % Creating the 3D variants of the matrices
    Ustar3D(:,1,:) = Ustar; 
    NS3D(1,:,:) = NS;
    
   % Create the 3D Kci matrix, one Gauss point per page
    Kci3D = bsxfun(@times, Ustar3D, NS3D); 
                                            
    % Performing the side integration and updating the Kci matrix
    w3D(1,1,:) = weight;
    Kci = Kci + L/2 * sum(bsxfun(@times,Kci3D,w3D),3); 
 
end

end

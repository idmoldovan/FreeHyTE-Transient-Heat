function RHS = Gen_BpXp_Vector(Edges,Loops,Xp,RHS,abscissa,weight)
% GEN_BPXP_VECTOR iterates through the edges and calls the function that 
% generates the Bp*Xp part of the free vector of the solving system 
% for the complementary solution.
%
% GEN_BPXP_VECTOR is called by MAIN***. It receives as input data the Edges
% and Loops structures, the RHS matrix (that is, the free vector of the
% solving system), the Gauss-Legendre integration parameters abscissa
% and weight, and the solution vector of the source function collocation
% procedure, Xp. It returns to MAIN*** the RHS vector with the Bp*Xp blocks
% of the Dirichlet and Robin edges inserted at the correct positions (as
% determined in ASSIGNPARTSCOMPL).
%
%
% BIBLIOGRAPHY
% 1. FreeHyTE Page - https://sites.google.com/site/ionutdmoldovan/freehyte
% 2. Moldovan ID, Cismasiu I - FreeHyTE: theoretical bases and developer’s 
% manual, https://drive.google.com/file/d/0BxuR3pKS2hNHTzB2N2Q4cXZKcGc/view
% 3. FreeHyTE Heat HTTE User's Manual - 
%    https://drive.google.com/drive/folders/0BxuR3pKS2hNHaFhiSjZHOE9TMzg
% 4. Moldovan ID, Coutinho AP, Cismasiu I - Hybrid-Trefftz finite elements
% for non-homogeneous parabolic problems using a novel dual reciprocity
% variant, Engineering Analysis with Boundary Elements, under review, 2018.
%
% Bp matrix is defined as the internal product between the following bases, 
% expressed in a polar (r,th) referential:
% * the temperature basis U generated by Bessel function of first kind, of
% order n and argument z= lambda_i*r (lambda_i are the 3 algorithmic wave
% numbers supplied by the user in the GUI),
%      U = Jn(z).* exp(1i*Th.*n);
% * the boundary flux basis Z (on the Dirichlet and Robin boundaries), 
% defined by Chebyshev polynomials,
%      Z  = cos(m*ArcCos(abscissa))
% where n and m are the line and column of the current term in matrix Bp.
%
% Further details on the structure of the solving system are presented in 
% reference [2] (Section 6.2). Its derivation is detailed in Reference [2],
% Section 3.2.3, and Reference [4], Section 4.4. 

%% Start iteration on edges
for ii=1:length(Edges.type)
    % Bp*Xp vectors are constructed for Dirichlet (and interior) and
    % Robin boundaries. 
    if strcmpi(Edges.type(ii),'D') || strcmpi(Edges.type(ii),'R')
        % LocEdge is a local structure where the features of the current
        % edge which are directly useful for the calculation of Bp are
        % stored.
        LocEdge =struct('id',ii,'nini',Edges.nini(ii),'nfin',Edges.nfin(ii),...
            'parametric',Edges.parametric(ii,:), 'lleft',Edges.lleft(ii),...
            'lright',Edges.lright(ii), 'order',Edges.order(ii),...
            'insert',Edges.insert(ii), 'dim',Edges.dim(ii));
        
        % Initialization
        Bp0left = zeros(LocEdge.dim,1);
        Bp0right = zeros(LocEdge.dim,1);
        
        % Generating the Bp matrix corresponding to the current edge
        % and its LEFT finite element
        if LocEdge.lleft
            % identify the current element
            id = LocEdge.lleft;
            % LocLoop is a local structure where the features of the left
            % element which are directly useful for the calculation of the
            % boundary block are stored.
            LocLoop = struct('id',id,'center',Loops.center(id,:),...
                'order',Loops.orderP(id,:),'lambda',Loops.lambda(id,:),'insert',...
                Loops.insertP(id,2),'dim',Loops.dimP(id,2),...
                'ohm',Loops.ohm(id));
            
            % Launching the function that computes the boundary
            % block Bp for the current edge ii and its left element
            Bpi = Bp_Matrix_i(LocEdge,LocLoop,abscissa,weight);
            % Extracting the particular solution vector corresponding to
            % the current element, according to the insertion point and
            % dimension calculated in ASSIGNPARTSPART
            Xpi = Xp(LocLoop.insert:LocLoop.insert+LocLoop.dim-1);
            % Computing the Bp*Xp vector for the left element
            Bp0left = Bpi*Xpi;
            
        end
        
        % Generating the Bp matrix corresponding to the current edge
        % and its RIGHT finite element
        if LocEdge.lright
            % identify the current element
            id = LocEdge.lright;
            % LocLoop is a local structure where the features of the right
            % element which are directly useful for the calculation of the
            % boundary block are stored.
            LocLoop = struct('id',id,'center',Loops.center(id,:),...
                'order',Loops.orderP(id,:),'lambda',Loops.lambda(id,:),'insert',...
                Loops.insertP(id,2),'dim',Loops.dimP(id,2),...
                'ohm',Loops.ohm(id));
            
            % Launching the function that computes the boundary
            % block Bp for the current edge ii and its right element
            Bpi = Bp_Matrix_i(LocEdge,LocLoop,abscissa,weight);
            % Extracting the particular solution vector corresponding to
            % the current element, according to the insertion point and
            % dimension calculated in ASSIGNPARTSPART            
            Xpi = Xp(LocLoop.insert:LocLoop.insert+LocLoop.dim-1);
            % Computing the Bp*Xp vector for the left element
            Bp0right = Bpi*Xpi;
 
        end
        
        % Inserting the Bp*Xp vectors in the global RHS vector
        RHS(LocEdge.insert:LocEdge.insert+LocEdge.dim-1) = ...
            RHS(LocEdge.insert:LocEdge.insert+LocEdge.dim-1)... 
            - Bp0right + Bp0left;
    end
    
end

end


function Bpi = Bp_Matrix_i(LocEdge,LocLoop,abscissa,weight)

% BP_MATRIX_I is a local function that computes the Bp boundary block for 
% LocEdge edge and LocLoop element. The side is mapped to a [-1,1] interval 
% to perform the integration.

%% Initialization
n = 0:LocEdge.order;
mB1 = -LocLoop.order(1):LocLoop.order(1);
mB2 = -LocLoop.order(2):LocLoop.order(2);
mB3 = -LocLoop.order(3):LocLoop.order(3);

%% Generating the geometric data
% The following code transforms the abscissa coordinates, expressed in
% the [-1,1] referential, to the polar coordinates required to compute
% the values of the basis functions. 

% Computing the length of the current edge
L = sqrt(LocEdge.parametric(3)^2 + LocEdge.parametric(4)^2); 

% Transforming the edge abscissa into local coordinates. The local
% referential is centered in the barycenter of the element, its axes
% aligned with the Cartesian axes of the global referential.
loc_x = LocEdge.parametric(1) - LocLoop.center(1) + 0.5 *...
    (abscissa + 1) * LocEdge.parametric(3);  
loc_y = LocEdge.parametric(2) - LocLoop.center(2) + 0.5 *...
    (abscissa + 1) * LocEdge.parametric(4);

% Transforming the local Cartesian coordinates into polar.
r = sqrt(loc_x.^2 + loc_y.^2);  
th = atan2(loc_y, loc_x);

%% Computing the basis functions for all integration points.

% Getting the Bessel functions' arguments
z1 = LocLoop.lambda(1) * r;
z2 = LocLoop.lambda(2) * r;
z3 = LocLoop.lambda(3) * r;

% Computing the boundary flux basis
Z = cos(bsxfun(@times,n,acos(abscissa)));
Zstar = Z'; % conjugate transposed

% Computing the temperature (particular solution) basis
UB1 = 1/(LocLoop.ohm^2-LocLoop.lambda(1)^2)*bsxfun(@besselj,mB1,z1) ...
    .* exp(1i*th*mB1);
UB2 = 1/(LocLoop.ohm^2-LocLoop.lambda(2)^2)*bsxfun(@besselj,mB2,z2) ...
    .* exp(1i*th*mB2);
UB3 = 1/(LocLoop.ohm^2-LocLoop.lambda(3)^2)*bsxfun(@besselj,mB3,z3) ...
    .* exp(1i*th*mB3);
% Concatenating the 3 parts of the basis
U = cat(2,UB1,UB2,UB3);
U = U.'; % non-conjugate transpose

% Creating the 3D variants of the matrices
Zstar3D(:,1,:) = Zstar;
U3D(1,:,:) = U; 

% this creates the 3D Bpi matrix, one Gauss point per page
Bpi3D = bsxfun(@times, Zstar3D, U3D); 

%% Integrating on the side
w3D(1,1,:) = weight;
Bpi = L/2 * sum(bsxfun(@times,Bpi3D,w3D),3); % computes the integral

end 
function RHS = Gen_KpXp_Vector(Edges,Loops,Xp,RHS,abscissa,weight)
% GEN_KPXP_VECTOR sweeps through the elements and calls the function 
% that generates the Kp*Xp part of the free vector of the solving system 
% for the complementary solution.
%
% GEN_KPXP_VECTOR is called by MAINREG. 
% Input data: 
% the Edges and Loops structures, vector Xp, solution of the source
% function collocation procedure, vector RHS, the status quo of the RHS
% vector, the Gauss abscissae and weights.
% Output/returns to MAINREG:
% the free vector of the complementary solution solving system, RHS
%
% BIBLIOGRAPHY
% 1. FreeHyTE Page - https://sites.google.com/site/ionutdmoldovan/freehyte
% 2. Moldovan ID, Cismasiu I - FreeHyTE: theoretical bases and developer’s 
% manual, https://drive.google.com/file/d/0BxuR3pKS2hNHTzB2N2Q4cXZKcGc/view
% 3. FreeHyTE Heat HTTE User's Manual - 
%    https://drive.google.com/drive/folders/0BxuR3pKS2hNHaFhiSjZHOE9TMzg
% 4. Moldovan ID, Coutinho AP, Cismasiu I - Hybrid-Trefftz finite elements
% for non-homogeneous parabolic problems using a novel dual reciprocity
% variant, Engineering Analysis with Boundary Elements, under review, 2018.
%
% Kp matrix is defined as the internal product between the following bases
% expressed in a polar (r,th) referential:
% * the complementary solution temperature basis Uc generated by Bessel
% function of first kind, of order n and argument z= ohm*r (ohm is the
% generalized frequency) 
%      Uc = Jn(z).* exp(1i*Th.*n);
% * the boundary normal particular solution flux basis N * Sp, where, 
%         Sp = | Sr | = -k/2 * lambda * exp(i*Th.*m) | Jm-1(z') + Jm+1(z')|
%              | St |                             | i*Jm-1(z') + Jm+1(z') |
% z' = lambda*r (lambda are the algorithmic wave numbers defined by the
% user) and N is the directory cosine vector, 
%         N = | nr  nt |
% In the above expressions, n and m are the line and column of the current 
% term in matrix Kp, k is the themal conductivity coefficient (see 
% INPUTPROC***), and nr and nt are the radial and tangential components of
% the outward unit normal to the current boundary.

% The procedure is detailed in Reference [2], Section 3.2.3, and Reference
% [4], Sections 4.3 and 4.4. 

%% Sweeping the elements
for ii=1:length(Loops.area)
    % LocLoop is a structure where the features of the current element
    % which are directly useful for the calculation of Kp are stored.
    LocLoop = struct('id',ii,'nodes',Loops.nodes(ii,:), 'edges', ...
        Loops.edges(ii,:),'center', Loops.center(ii,:),...
        'orderP', Loops.orderP(ii,:),'orderC', Loops.orderC(ii),...
        'insertP',Loops.insertP(ii,2),'insertC',Loops.insertC(ii),... % insertP(ii,2) is the insertion point of Xs
        'dimP',Loops.dimP(ii,2),'dimC',Loops.dimC(ii),... % dimP(ii,2) is the size of Xs
        'lambda',Loops.lambda(ii,:),'material',Loops.material(ii,:),...
        'ohm',Loops.ohm(ii));
    
    % Computing the Kp matrix
    Kpi = Kp_Matrix_i(Edges,LocLoop,abscissa,weight);
    
    % Extracting the Xp solution of the current element from vector Xp. The
    % insertion point and dimension were computed in ASSIGNPARTSPART
    Xpi = Xp(LocLoop.insertP:LocLoop.insertP+LocLoop.dimP-1);
    
    % Inserting the vector in the global RHS vector. The insertion point
    % and dimension were computed in ASSIGNPARTSCOMPL
    RHS(LocLoop.insertC:LocLoop.insertC+LocLoop.dimC-1) = ...
        RHS(LocLoop.insertC:LocLoop.insertC+LocLoop.dimC-1) - Kpi*Xpi;
    
end

end

function Kpi = Kp_Matrix_i(Edges,LocLoop,abscissa,weight)
% KP_MATRIX_I is a local function that computes the  Kp matrix of the
% LocLoop element. The sides are mapped to a [-1,1] interval to perform the
% required integrations. 

%% Initialization 
% Initialization of the Kpi block
Kpi = zeros(LocLoop.dimC,LocLoop.dimP);
% Loading the orders of the bases and the heat conduction coefficient
n = -LocLoop.orderC:LocLoop.orderC;
mB1 = -LocLoop.orderP(1):LocLoop.orderP(1);
mB2 = -LocLoop.orderP(2):LocLoop.orderP(2);
mB3 = -LocLoop.orderP(3):LocLoop.orderP(3);
k = LocLoop.material(1);

% Iterating on the edges for contour integration
for kk = 1:length(LocLoop.edges)  % contour integration
    
    id = LocLoop.edges(kk);  % number of the kk-th edge of the loop
    
    % LocEdge is a local structure where the features of the current
    % edge which are directly useful for the calculation of the
    % Kp block are stored.    
    LocEdge =  struct('id',id,'nini',Edges.nini(id), 'nfin',...
        Edges.nfin(id),'parametric',Edges.parametric(id,:), ...
        'lleft',Edges.lleft(id),'lright',Edges.lright(id));
    
    %% Generating the geometric data
    % The following code transforms the abscissa coordinates, expressed in
    % the [-1,1] referential, to the polar coordinates required to compute
    % the values of the basis functions. The components of the outward
    % normal to the boundary in the radial and tangential directions are
    % also calculated. 
    
    % Computing the length of the current edge
    L = sqrt(LocEdge.parametric(3)^2 + LocEdge.parametric(4)^2); 
    
    % Transforming the edge abscissa into global coordinates.      
    GlobalX = LocEdge.parametric(1) + 0.5 *...
        (abscissa + 1) * LocEdge.parametric(3);  
    GlobalY = LocEdge.parametric(2) + 0.5 *...
        (abscissa + 1) * LocEdge.parametric(4);  
    
    % Transforming the edge abscissa into local coordinates. The local
    % referential is centered in the barycenter of the element, its axes
    % aligned with the Cartesian axes of the global referential.
    x = GlobalX - LocLoop.center(1);
    y = GlobalY - LocLoop.center(2);
    % Transforming the edge abscissa into polar coordinates.
    R = sqrt(x.^2 + y.^2);  
    T = atan2(y, x);
    
    % Computing the components of the outward normal in the Cartesian
    % directions.
    nx = LocEdge.parametric(4) / L;   
    ny = -1* LocEdge.parametric(3) / L;
    if LocEdge.lright==LocLoop.id  % if the element is on the right,
        nx = -nx;                 % change the sign of the normal
        ny = -ny;
    end
    
    % Computing the components of the outward normal in the polar
    % directions.
    NR = nx * cos(T) + ny * sin(T);   % normal in local r-th (mini)
    NT = -1*nx * sin(T) + ny * cos(T);
    
    %% Computing the basis functions for all integration points
    % Computing the arguments of the basis functions
    Z = LocLoop.ohm * R;
    Z1 = LocLoop.lambda(1) * R;
    Z2 = LocLoop.lambda(2) * R;
    Z3 = LocLoop.lambda(3) * R;
    % Computing the complex conjugate of the Uc basis
    Ustar = conj(bsxfun(@besselj,n,Z) .* exp(1i*T*n));
    
    % Sp computation 
        
    % Polar components (Sr and Sth) of the flux basis Sp. This calculation
    % is made for all three lambdas.
    SrB1 = 0.5 * LocLoop.lambda(1) * (bsxfun(@besselj,mB1-1,Z1) -...
        bsxfun(@besselj,mB1+1,Z1)) .* exp(1i*T*mB1);
    SthB1 = 0.5 * LocLoop.lambda(1) * 1i * (bsxfun(@besselj,mB1-1,Z1) +...
        bsxfun(@besselj,mB1+1,Z1)) .* exp(1i*T*mB1);
    NSB1 = -k/(LocLoop.ohm^2-LocLoop.lambda(1)^2)*(bsxfun(@times,NR,SrB1)...
        + bsxfun(@times,NT,SthB1));
    
    SrB2 = 0.5 * LocLoop.lambda(2) * (bsxfun(@besselj,mB2-1,Z2) -... 
        bsxfun(@besselj,mB2+1,Z2)) .* exp(1i*T*mB2);
    SthB2 = 0.5 * LocLoop.lambda(2) * 1i * (bsxfun(@besselj,mB2-1,Z2) +... 
        bsxfun(@besselj,mB2+1,Z2)) .* exp(1i*T*mB2);
    NSB2 = -k/(LocLoop.ohm^2-LocLoop.lambda(2)^2)*(bsxfun(@times,NR,SrB2)...
        + bsxfun(@times,NT,SthB2));
    
    SrB3 = 0.5 * LocLoop.lambda(3) * (bsxfun(@besselj,mB3-1,Z3) -...
        bsxfun(@besselj,mB3+1,Z3)) .* exp(1i*T*mB3);
    SthB3 = 0.5 * LocLoop.lambda(3) * 1i * (bsxfun(@besselj,mB3-1,Z3) +...
        bsxfun(@besselj,mB3+1,Z3)) .* exp(1i*T*mB3);
    NSB3 = -k/(LocLoop.ohm^2-LocLoop.lambda(3)^2)*(bsxfun(@times,NR,SrB3)... 
        + bsxfun(@times,NT,SthB3));
    
    % Concatenating the parts of the Sp basis belonging to the three wave
    % numbers.
    NS = cat(2,NSB1,NSB2,NSB3);
    
    %% Computing the integral on the side
    % The integral is the internal product between temperature basis Uc*
    % and the normal flux basis N*Sp
    Ustar = Ustar.'; % non-conjugate transpose
    NS = NS.';
    
    % Creating the 3D variants of the matrices
    Ustar3D(:,1,:) = Ustar; 
    NS3D(1,:,:) = NS;
    
    % Create the 3D Kpi matrix, one Gauss point per page
    Kpi3D = bsxfun(@times, Ustar3D, NS3D);
    
    % Performing the side integration and updating the Kpi matrix
    w3D(1,1,:) = weight;
    Kpi = Kpi + L/2 * sum(bsxfun(@times,Kpi3D,w3D),3);
    
end

end